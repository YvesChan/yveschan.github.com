<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Hello YC]]></title>
  <link href="http://YvesChan.github.com/atom.xml" rel="self"/>
  <link href="http://YvesChan.github.com/"/>
  <updated>2013-07-13T16:14:44+08:00</updated>
  <id>http://YvesChan.github.com/</id>
  <author>
    <name><![CDATA[YvesChan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Software Defined Networking - Note 1]]></title>
    <link href="http://YvesChan.github.com/blog/software-defined-networking-note-1/"/>
    <updated>2013-07-13T15:21:00+08:00</updated>
    <id>http://YvesChan.github.com/blog/software-defined-networking-note-1</id>
    <content type="html"><![CDATA[<blockquote><p>SDN (Software-Defined Networking) is an approach to computer networking which abstracts the distributed systems, the control plane and the data plane.</p>

<pre><code>                                                    -- from Wikipedia
</code></pre></blockquote>

<p>刚好coursera的SDN课程开在暑假，总算有个课是想上又有时间上了 = =</p>

<p>这里权当是做个笔记。因为本人英语渣，如果不作笔记的话基本上过了没多久就忘得一干二净了（虽然现在也差不多）。</p>

<p>实话说，课程比较抽象，ppt过了第一遍基本上就云里雾里了，很多地方都是知其然不知其所以然。虽然SDN是针对数据中心网络的技术，但是个人觉得网络硬件在这几年来确实没什么重大的革命（菜鸟我没听说过有咯），而现在各大互联网公司都在抢占用户上网入口，也就是路由器。如果SDN走出学术界，在工业界量产的话，那也算的上是网络硬件的革命了。难怪SDN会被称为Computer Network的X86。当然目前离大规模普及还是长路漫漫啊，具体面临的困难这里略去不表&#8230;（表不了啊）</p>

<p>以下内容参照 Coursera 的 <a href="https://class.coursera.org/sdn-001/wiki/view?page=syllabus">SDN open course</a></p>

<!--more-->


<h1>Week 1</h1>

<h2>Active Networks</h2>

<ul>
<li><p>definition: Networks where switches perform custom computations on packets.(交换机在数据包上执行自定义操作的一种网络)</p></li>
<li><p>idea: Message carry procedures &amp; data</p>

<ul>
<li><p>Active routers coexist with legacy routers</p></li>
<li><p>Each programmable switch can perform additional processing</p></li>
</ul>
</li>
<li><p>Two different approaches</p>

<ul>
<li><p>Capsules(&#8220;integrated&#8221;)(代码和数据整合到packet中)</p></li>
<li><p>Programmable Switches(&#8220;discrete&#8221;)(代码运行在路由器中，数据存储于packet，由header指定运行程序)</p></li>
</ul>
</li>
</ul>


<h2>Network Virtualization</h2>

<ul>
<li><p>definition: Representation of one or more logical network topologies on the same infrastructure.(在同一个基础设施上表现出一个或多个网络拓扑结构)</p></li>
<li><p>motivation: Separate logical network from physical infrastructure, potentially allow users to share the same underlying infrastructure for different purpose.(将逻辑的拓扑结构与物理基础设施分离以实现共享)</p></li>
<li><p>benefits:</p>

<ul>
<li><p>Sharing</p></li>
<li><p>Customizability</p></li>
</ul>
</li>
</ul>


<h1>Week 2</h1>

<h2>Control plane(控制层)</h2>

<ul>
<li><p>definition: Logic for controlling forwarding behavior(控制转发行为的逻辑，类似网络的大脑)</p></li>
<li><p>e.g. routing protocol, network middlebox configuration(firewall,Load Balance)</p></li>
</ul>


<h2>Data plane(数据层)</h2>

<ul>
<li><p>definition: Forward traffic according to control plane logic(根据控制层的逻辑来转发流量)</p></li>
<li><p>e.g. IP forwarding(即三层路由，根据IP地址进行转发), layer-2 switching(根据MAC地址进行转发)</p></li>
</ul>


<h2>Reason for separate thr Control and Data plane</h2>

<ul>
<li><p>Independent evolution and development</p></li>
<li><p>Control from high-level software program:</p></li>
</ul>


<blockquote><p>Once the control plane is separated from data plane, it&#8217;s a lot easier to control the behavior of the network, because those switches are doing nothing more than just forwarding traffic, and all the smart of network are in the software control.</p></blockquote>

<h2>Challenges from control/data plane separation</h2>

<ul>
<li><p>scalability: routing decisions for many routers</p></li>
<li><p>reliability: correct operation under failure</p></li>
<li><p>consistency: ensuring consistency across multiple control replicas</p></li>
</ul>


<h2>mininet(openflow tutorial)</h2>

<p><strong>mininet</strong> : A network emulation platform that has the ability to create a virtual OpenFlow network; controllers, switches, hosts, and links on a single real or virtual network.</p>

<h3>init</h3>

<p><code>sudo mn --topo single,3 --mac --switch ovsk --controller remote</code></p>

<ul>
<li>sudo mn : This starts mininet. Mininet always requires sudo to run.</li>
<li>&#8211;topo single,3 : This tells mininet to start using the topology of a ‘single’ switch and 3 hosts.</li>
<li>&#8211;mac : This tells mininet to assign each host a sequential mac address, matching its IP address.</li>
<li>&#8211;switch ovsk : This tells mininet that the switches are to be of the type ovsk, this is the type for Openflow,</li>
<li>&#8211;controller remote : This tells mininet that each Openflow switch is to talk to a controller, which is located at a remote location.</li>
<li>&#8211;link : This sets link parameters, e.g. bw(bandwidth), delay</li>
</ul>


<p>Here&#8217;s the topology:</p>

<p><img src="http://www.openflow.org/wk/images/c/c6/Three_switch_layout_simple.png" alt="mininet" /></p>

<h3>dpctl</h3>

<p><code>dpctl</code> is a utility that comes with the OpenFlow reference distribution and enables visibility and control over a single switch&#8217;s flow table</p>

<pre>
# forward packets coming at port 1 to port 2
dpctl add-flow tcp:127.0.0.1:6634 in_port=2,actions=output:3

# check the flow-table
dpctl dump-flows tcp:127.0.0.1:6634
</pre>


<p>Note: the <em>idle_timeout</em> para means that the flow will expire after this many secs if there is no incoming traffic.</p>

<pre>dpctl add-flow tcp:127.0.0.1:6634 in_port=2,idle_timeout=120,actions=output:3</pre>


<h3>iperf</h3>

<p><code>iperf</code> is a command-line tool for checking speeds between two computers.</p>

<pre>
# create an user space network
sudo mn --topo single,3 --controller remote --switch user
# Here we have used ‘user’ with --switch option instead of ‘ovsk’. This loads mininet with user-space switch.

# start a simple controller that acts as a learning switch without installing any flow-entries.
$ controller ptcp:

# test speed
mininet> iperf
# With the user-space switch, packets must cross from user-space to kernel-space and back on every hop, rather than staying in the kernel as they go through the switch. The user-space switch is easier to modify, but slower for simulation.

</pre>


<h2>summary</h2>

<ul>
<li><strong>OpenFlow Interface</strong> : a standard open interface between the OpenFlow controller and the OpenFlow programmable devices (i.e., switches etc)</li>
<li><strong>OpenFlow Controller</strong> : sits <em>above</em> the OpenFlow interface. The OpenFlow reference distribution includes a controller that acts as an Ethernet learning switch in combination with an OpenFlow switch. You&#8217;ll run it and look at messages being sent.</li>
<li><strong>OpenFlow Switch</strong> : sits <em>below</em> the OpenFlow interface. The OpenFlow reference distribution includes a user-space software switch. <code>Open vSwitch</code> is another software but <em>kernel-based</em> switch.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shadowsocks 源码解释]]></title>
    <link href="http://YvesChan.github.com/blog/shadowsocks-analysis/"/>
    <updated>2013-05-18T09:10:00+08:00</updated>
    <id>http://YvesChan.github.com/blog/shadowsocks-analysis</id>
    <content type="html"><![CDATA[<blockquote><p>对于科学上网这种事，我向来一丝不苟。</p>

<p>但本po的主题并不是如何科学上网，而是深入了解proxy背后的原理。</p></blockquote>

<h2>Preface</h2>

<p>去年shadowsocks在V2EX刚<a href="http://www.v2ex.com/t/32777">发布</a>的时候，我就已经开始留意这个项目。当时还在用Goagent，但有时候速度确实不咋的，而且重新配置的话会比较麻烦。9月份入手VPS之后开始折腾PPTP VPN，效果相当不稳定。不久后OpenVPN也开始受到干扰了。看来必须寻找比较小众的方式，避免躺枪。因此，初试shadowsocks（python版），速度或者稳定性都相当好，一直用到现在，未出现过什么问题。配置也很简单，唯一的门槛就是需要国外的Linux 主机（VPS）。现在shadowsocks项目已经发展到多语言跨平台了，社区也比较活跃，主要原因是项目架构简单，代码精简易于维护。</p>

<p>一周前开始学习python，主要是想用python写一个爬虫。大概用了4天的课余时间把 《Dive Into Python3》过了一遍，了解基本语法。结合文档看大牛的源码是很好的学习方式，所谓learn by doing嘛。不得不说，shadowsocks的源码真心简洁，再看一下SOCK5协议的报文格式，并没有花很多时间。貌似说了不少废话，现在入正题= =！</p>

<!--more-->


<h2>Socks5</h2>

<p>首先介绍一下socks5协议：
SOCKS协议位于传输层(TCP/UDP等)与应用层之间，其工作流程为</p>

<ol>
<li>client向proxy发出请求信息，用以协商传输方式</li>
<li>proxy作出应答</li>
<li>client接到应答后向proxy发送目的主机（destination server)的ip和port</li>
<li>proxy评估该目的主机地址，返回自身IP和port，此时C/P连接建立。</li>
<li>proxy与dst server连接</li>
<li>proxy将client发出的信息传到server，将server返回的信息转发到client。代理完成</li>
</ol>


<h3>client连接proxy的第一个报文信息，进行认证机制协商</h3>

<table border="1">
    <tr>
        <td>version</td>
        <td>nmethod</td>
        <td>methods</td>
    </tr>
    <tr>
        <td>1 Bytes</td>
        <td>1 Bytes</td>
        <td>1 to 255 Bytes</td>
    </tr>
</table>


<p>一般是 hex: 05 01 00
即：版本5，1种认证方式，NO AUTHENTICATION REQUIRED(无需认证 0x00)</p>

<h3>proxy从METHODS字段中选中一个字节(一种认证机制)，并向Client发送响应报文:</h3>

<table border="1">
    <tr>
        <td>version</td>
        <td>methods</td>
    </tr>
    <tr>
        <td>1</td>
        <td>1</td>
    </tr>
</table>


<p>一般是 hex: 05 00
即：版本5，无需认证</p>

<h3>认证机制相关的子协商完成后，Client提交转发请求:</h3>

<table border="1">
    <tr>
        <td>VER</td>
        <td>CMD</td>
        <td>RSV</td>
        <td>ATYP</td>
        <td>DST.ADDR</td>
        <td>DST.PORT</td>
    </tr>
    <tr>
        <td>1</td>
        <td>1</td>
        <td>0x00</td>
        <td>1</td>
        <td>variable</td>
        <td>2</td>
    </tr>
</table>


<p>前3个一般是 hex: 05 01 00
地址类型可以是
* 0x01    IPv4地址
* 0x03    FQDN(全称域名)
* 0x04    IPv6地址</p>

<p>对应不同的地址类型，地址信息格式也不同：
* IPv4地址，这里是big-endian序的4字节数据
* FQDN，比如&#8221;www.nsfocus.net&#8221;，这里将是:0F 77 77 77 2E 6E 73 66 6F 63 75 73 2E 6E 65 74。注意，第一字节是长度域
* IPv6地址，这里是16字节数据。</p>

<h3>proxy评估来自Client的转发请求并发送响应报文</h3>

<table border="1">
    <tr>
        <td>VER</td>
        <td>REP</td>
        <td>RSV</td>
        <td>ATYP</td>
        <td>BND.ADDR</td>
        <td>BND.PORT</td>
    </tr>
    <tr>
        <td>1</td>
        <td>1(response)</td>
        <td>0x00</td>
        <td>1</td>
        <td>variable</td>
        <td>2</td>
    </tr>
</table>


<p>Proxy可以靠DST.ADDR、DST.PORT、SOCKSCLIENT.ADDR、SOCKSCLIENT.PORT进行评估，以决定建立到转发目的地的TCP连接还是拒绝转发。若允许则响应包的REP为0，非0则表示失败（拒绝转发或未能成功建立到转发目的地的TCP连接）。</p>

<h2>shadowsocks source code</h2>

<p>源代码方面，主要是由socks5转发模块和加密解密模块组成</p>

<p>转发模块感觉比较简单，但是个人觉得有几点需要注意的地方，或者说我自己不太明白。（python菜，请谅解）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;config.json&#39;</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
</span><span class='line'>    <span class="n">config</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</span><span class='line'><span class="n">SERVER</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s">&#39;server&#39;</span><span class="p">]</span>
</span><span class='line'><span class="n">REMOTE_PORT</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s">&#39;server_port&#39;</span><span class="p">]</span>
</span><span class='line'><span class="n">PORT</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s">&#39;local_port&#39;</span><span class="p">]</span>
</span><span class='line'><span class="n">KEY</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s">&#39;password&#39;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<h3>client</h3>

<ul>
<li>从main开始，读取配置。这里为什么要用二进制的方式打开json文件呢？</li>
<li>解释命令行参数 <code>optlist, args = getopt.getopt(sys.argv[1:], 's:p:k:l:')</code>，这个跟Linux的getopt函数差不多，可以自己man一下。</li>
<li>设置logging等级和信息，生成密文表（包括加密解密）。</li>
<li>运行 ThreadingTCPServer 实例。从定义看， <code> class ThreadingTCPServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer) </code> 子类化ThreadingTCPServer（多重继承继承ThreadingMixIn类和TCPServer类），即使用多线程处理TCP请求（Mix-in class to handle each request in a new thread），同时设置其类属性allow_reuse_address。这里绑定的地址是(&#8221;,PORT)，意思是该套接字对于本机的任何地址都是可达的。BaseRequestHandler 则由 Socks5Server 子类实现。由于 SocketServer module 包含了很多socket programming的细节，所以代码看起来相当简洁。</li>
<li>每当有请求到达，调用 handle 函数，主要是建立proxy到client和server的连接，然后调用 handle_tcp 函数来转发TCP数据包(包括client to server或相反方向)，对于server来说，proxy是完全透明的。当然，这里client和proxy之间的数据交互需要通过加密传输。</li>
<li>对于handle_tcp而言，它需要同时处理两个socket（client &amp; server），这里使用了I/O multiplexing的方式，选择select作为实现。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">handle_tcp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">remote</span><span class="p">):</span>
</span><span class='line'>    <span class="k">try</span><span class="p">:</span>
</span><span class='line'>        <span class="n">fdset</span> <span class="o">=</span> <span class="p">[</span><span class="n">sock</span><span class="p">,</span> <span class="n">remote</span><span class="p">]</span>
</span><span class='line'>        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class='line'>            <span class="n">r</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">fdset</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[])</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">sock</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
</span><span class='line'>                <span class="n">data</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
</span><span class='line'>                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>                    <span class="k">break</span>
</span><span class='line'>                <span class="n">result</span> <span class="o">=</span> <span class="n">send_all</span><span class="p">(</span><span class="n">remote</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">decrypt</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</span><span class='line'>                <span class="k">if</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
</span><span class='line'>                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;failed to send all data&#39;</span><span class="p">)</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">remote</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
</span><span class='line'>                <span class="n">data</span> <span class="o">=</span> <span class="n">remote</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
</span><span class='line'>                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>                    <span class="k">break</span>
</span><span class='line'>                <span class="n">result</span> <span class="o">=</span> <span class="n">send_all</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</span><span class='line'>                <span class="k">if</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
</span><span class='line'>                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;failed to send all data&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">finally</span><span class="p">:</span>
</span><span class='line'>        <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span><span class='line'>        <span class="n">remote</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于高性能并发服务器而言，这是一种非常重要的手段。当然还是其他实现方式，例如poll,epoll,kqueue等。这里由于文件描述符数量较小，所以分别也不大了。更详细的信息可以看 <a href="http://www.kegel.com/c10k.html">C10K problem</a></p>

<h3>server</h3>

<p>服务端代码与客户端差不多，主要是数据报文的解释和转发问题。主要是处理好在client端发送过来的自定数据格式，转发到目的地址server，再将返回的数据转发给client。</p>

<p>更多的细节我都在<a href="https://github.com/YvesChan/shadowsocks">源码</a>上注释了，有兴趣可以看看。</p>

<p>整个架构图大概这样：（就不要吐槽画的有多丑了= =）</p>

<p><img src="http://ww3.sinaimg.cn/mw690/693e3eb0gw1e4uzpuiyh9j20ff0dvaat.jpg" alt="arch" /></p>

<hr />

<p>Reference:</p>

<p><a href="http://blog.csdn.net/liufan1945/article/details/8053804">Socks5详解（RFC）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Blood]]></title>
    <link href="http://YvesChan.github.com/blog/first-blood/"/>
    <updated>2013-03-19T21:54:00+08:00</updated>
    <id>http://YvesChan.github.com/blog/first-blood</id>
    <content type="html"><![CDATA[<blockquote><p>First Blood</p>

<p>出自ACM/ICPC
形容某道题第一个AC的team称为拿到了该题的 <em>First Blood</em></p></blockquote>

<p>一直想测试一下Octopress的使用体验，花了一个晚上折腾Ruby的安装环境和各种各样的奇怪问题，总算是弄好了。</p>

<p>说起来最近折腾了不少东西，比如Sublime Text 2的各种plugins，比如zsh，比如tmux，etc。真心觉得生命在于折腾啊。越来越体会到先进的工具对生产力的影响了。神器如ST2，如果使用得当，绝对是可敌IDE，但是要记得那么多快捷键也不是那么容易啊。vim的话，我也常用，但是只能算入门。大概就是八二原理吧，百分之八十的时间只用到百分之二十的功能。</p>

<p>原来的博客放在Blogspot上面，写po的时候非常不方便，比如不支持markdown，比如代码高亮要添加各种插件，比如被墙（这个才是最重要的）。另外数据导出和备份也是个问题。之前想在VPS上鼓捣wordpress，但是感觉吧，还是不够纯粹，加上WP默认主题太多槽点。Orz 虽然说WP也是有很多可折腾的地方，但是吧我发现如果不通过点什么东西来巩固我的git技能和markdown语法，估计要掉的差不多了 = =</p>

<p>网上关于octopress的教程一陀陀的，我就不重复了。然后比较蛋疼的ST2的中文输入问题一直没有解决，然后vim输入中文感觉灰常怪，所以就gedit先凑合着。突然想起一个比较蛋疼的问题：如果在别的机器上要写blog，那岂不是也要有Ruby的环境？看来要尽快考虑将静态网页生成的工作交由服务器负责了。果然什么都是有利有弊啊，更多优缺点有待发现ing&#8230;.</p>

<p>其实呢，折腾虽说是由个人喜好决定，但是也不要太过了，码农还是以敲代码为主嘛，只停留在一些应用层面上的东西没什么太大的意思，这也是我不愿意折腾UI的原因&#8230;</p>

<p>PS: 原先的Blog在<a href="http://shanks-chan.blogspot.com">Blogspot</a>由于贴代码太不方便了，而且被墙，应该不会再更新&#8230;.</p>
]]></content>
  </entry>
  
</feed>
