<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Hello YC]]></title>
  <link href="http://YvesChan.github.com/atom.xml" rel="self"/>
  <link href="http://YvesChan.github.com/"/>
  <updated>2013-09-22T11:28:20+08:00</updated>
  <id>http://YvesChan.github.com/</id>
  <author>
    <name><![CDATA[YvesChan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Software-Defined Networking - Note 3]]></title>
    <link href="http://YvesChan.github.com/blog/software-defined-networking-note-3/"/>
    <updated>2013-09-02T22:41:00+08:00</updated>
    <id>http://YvesChan.github.com/blog/software-defined-networking-note-3</id>
    <content type="html"><![CDATA[<h1>Week 4 - SDN Nuts and Bolts(螺母和螺栓) - Control Plane</h1>

<p>===================</p>

<h2>Learing objectives:</h2>

<ul>
<li>Review how an SDN controller can populate(填充) a switch&#8217;s forwarding table.</li>
<li>Determine how an SDN controller can be used to control multiple switches in a single network, and why to do so.</li>
<li>Gain experience setting up a controller and basic switch environment.</li>
<li>Understand the design tradeoffs between some of the more commonly used SDN/OpenFlow controllers. (一些广泛使用的控制器之间的设计抉择)</li>
<li>Set up controller in Mininet that can perform basic operations,like switch-table population and firewalling.</li>
</ul>


<h2>Control plane basics</h2>

<h3>Openflow protocol specification(协议规范) (pic in PPT - P6)</h3>

<ul>
<li><p><code>OpenFlow controller</code> communicates with <code>switch</code> over Secure channel</p>

<ul>
<li>OF protocol defines msg format</li>
<li>controller use control channel to update flow table</li>
<li>logic is executed at controller</li>
</ul>
</li>
<li><p><code>Switch components</code> including:</p>

<ul>
<li>flow tables: perform packet lookup, if matching then take <code>action</code>

<ul>
<li>actions: forward, drop, modify, enqueue</li>
<li>flow table format:</li>
</ul>
</li>
</ul>
</li>
</ul>


<pre>
 switch| MAC      |Eth |VLAN|IP               |TCP/UDP
 port  |[src][dst]|type|ID  |[src][dst][proto]|[sport][dport]|action
</pre>


<ul>
<li>secure channel</li>
</ul>


<p>控制器与OF交换机之间通过SSL连接，使用OF协议进行通信，并在交换机上设置和更新流表。交换机只负责根据流表处理数据包，因此所有的逻辑都在控制器。每个数据包协议头部与所有流表(flow table)一一对比，如果匹配则执行相应的操作，如果所有都不匹配则发送到控制器(controller)。</p>

<ul>
<li><code>dpctl</code> Control channel

<ul>
<li>switches default port: 6634</li>
<li>inspect, modify flow table</li>
</ul>
</li>
</ul>


<p>Even in the absence of a controller, we can use dpctl to talk to the switch.</p>

<!-- more -->


<h3>Openflow enhancements(v1.3)</h3>

<ul>
<li>action set: 对每个包执行多个操作</li>
<li>group: a list of action sets. 一个pipeline中包含多个table，每个match的table可以把更新数据包特定域(filed)的操作(action)添加到action set中，在到达出口(output port)前执行所有action set中的action.见P10</li>
</ul>


<h2>SDN controller</h2>

<h2>Using SDN controllers to customize control</h2>

<h3>Hub and learning switch</h3>

<ul>
<li>Hub

<ul>
<li>no forwarding info stored at switch</li>
<li>every input packet is flooded out all ports</li>
</ul>
</li>
</ul>


<p>Start a <code>POX controller</code> by running hub.py. When the POX controller receive a connection request, it send back the msg with modifying flow table entries(flood).</p>

<ul>
<li><p>learning switch(algorithm)</p></li>
<li><p>Important concept: Listener</p></li>
</ul>


<h3>Simple firewall(Important)</h3>

<ul>
<li>performance: cache decisions at switch(把控制器的操作缓存在交换机以提高网络性能)

<ul>
<li>important to limit data traffic to controller</li>
<li>when controller decides to forward or drop, the flow table is modified.</li>
<li>decision is cache at switch until the flow table entry expired</li>
</ul>
</li>
</ul>


<p>当主机A要ping主机B时，第一个数据包的延时会比较大，因为交换机此时还没有flow table，需要把packet转发到controller，等controller根据rules作出转发决定，同时缓存该决定。每一段时间都会有一个icmp包的延时比较大，是因为flow table entry过期，要重复上述操作。</p>

<hr />

<h2>Experiment</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>sudo dhclient eth1
</span><span class='line'><span class="nv">$ </span>sudo mn --topo single,3 --max --switch ovsk --controller remote     <span class="c"># create a simple topologic with 3 hosts &amp; 1 OpenvSwitch</span>
</span><span class='line'><span class="nv">$ </span>pox/pox.py log.level --DEBUG forwarding.hub     <span class="c"># start a pox&#39;s hub component</span>
</span><span class='line'><span class="nv">$ </span>dpctl dump-flows tcp:127.0.0.1:6634    <span class="c"># check the flow table in switch</span>
</span></code></pre></td></tr></table></div></figure>


<p>POX工作方式很简单，pox.py文件启动POX，并且后面接上需要载入的模块名字，可以一次接入多个模块，POX会执行模块中的launch()函数并将模块的状态设置为“up”，并且在模块后面可以给模块指定参数的。</p>

<h3>useful API</h3>

<ul>
<li><p>connection.send()</p></li>
<li><p>ofp_action_output(port = ..): a flow table action class.  It specifies a switch port that you wish to send the packet out of.</p></li>
<li><p>ofp_match class</p></li>
<li><p>ofp_packet_out()</p></li>
<li><p>ofp_flow_mod(): OpenFlow modification msg. This instructs a switch to install a flow table entry.</p></li>
</ul>


<h3>firewall behavior</h3>

<ul>
<li>Hash table for storing K/V pairs (switch, src MAC)</li>
<li>drop: if there is a firewall entry maps to &#8220;False&#8221; or no match entry</li>
<li>forward: match a firewall entry that maps to &#8220;True&#8221;</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Software Defined Networking - Note 2]]></title>
    <link href="http://YvesChan.github.com/blog/software-defined-networking-note-2/"/>
    <updated>2013-09-01T21:49:00+08:00</updated>
    <id>http://YvesChan.github.com/blog/software-defined-networking-note-2</id>
    <content type="html"><![CDATA[<h1>Week 3</h1>

<h2>Learning Objectives:</h2>

<ul>
<li>Discover what network virtualization is and why it is used</li>
<li>Identify various ways of implementing virtual networks</li>
<li>Explain why Mininet is useful</li>
<li>Practice how Mininet works</li>
<li>Gain more experience using Mininet, setting up topologies, etc.</li>
</ul>


<h2>Network virtualization</h2>

<h3>definition: Abstraction of the physical network(物理网络的抽象)</h3>

<ul>
<li>support multiple logical networks share a physical substrate(多个逻辑网络共享物理基础设施)</li>
<li>container of network services</li>
</ul>


<h3>Aspects of network virtualization(网络虚拟化的应用层面)</h3>

<ul>
<li>Nodes: VM</li>
<li>Links: Tunnels</li>
<li>Storage</li>
</ul>


<h3>Motivation &amp; Goal</h3>

<ul>
<li>Flexibility</li>
<li>Manageability</li>
<li>Scalability</li>
<li>Security &amp; Isolation</li>
<li>Programmability</li>
<li>Heterogeneity(异质性): 支持不同技术</li>
</ul>


<h3>Virtual switch(虚拟交换技术)</h3>

<p>Mechanism that taking Ethernet frames inside a VM and passing them to the physical interface, which networking VM together over L2 topology.(通过虚拟交换技术将虚拟机连接到二层网络)</p>

<p>Example:
* short-bridge in VINI: extension of Linux bridging(桥接)
* Open vSwitch: can be configured remotely with OpenFlow, json</p>

<h2>Application of virtual networking</h2>

<ul>
<li>Experimental deployments</li>
<li>Isolation on shared infrastructure</li>
<li>Reuse of resource pool</li>
<li>Dynamic scaling</li>
<li>Easier management of logical resources</li>
</ul>


<h2>Virtual network in Mininet</h2>

<h3>Mininet</h3>

<p>difiniton: a <code>virtual network environment</code> that can run on a single PC</p>

<p><em>Mininet</em> VM architecture paradigm(review it in ppt/pdf):</p>

<ol>
<li>lanuch mininet process(mn)</li>
<li>create subprocesses(/bin/bash) &amp; network namespace in per vhost</li>
<li>create virtual ethernet(veth) pairs and assign to namespace(establish tunnel between virtual interface(VHost) and real interface(local).)</li>
<li>create OpenFlow switch to connect vhosts</li>
<li>create OpenFlow controller to control flow table entries in switch through OpenFlow protocol</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Software Defined Networking - Note 1]]></title>
    <link href="http://YvesChan.github.com/blog/software-defined-networking-note-1/"/>
    <updated>2013-07-13T15:21:00+08:00</updated>
    <id>http://YvesChan.github.com/blog/software-defined-networking-note-1</id>
    <content type="html"><![CDATA[<blockquote><p>SDN (Software-Defined Networking) is an approach to computer networking which abstracts the distributed systems, the control plane and the data plane.</p>

<pre><code>                                                    -- from Wikipedia
</code></pre></blockquote>

<p>刚好coursera的SDN课程开在暑假，总算有个课是想上又有时间上了 = =</p>

<p>这里权当是做个笔记。因为本人英语渣，如果不作笔记的话基本上过了没多久就忘得一干二净了（虽然现在也差不多）。</p>

<p>实话说，课程比较抽象，ppt过了第一遍基本上就云里雾里了，很多地方都是知其然不知其所以然。虽然SDN是针对数据中心网络的技术，但是个人觉得网络硬件在这几年来确实没什么重大的革命（菜鸟我没听说过有咯），而现在各大互联网公司都在抢占用户上网入口，也就是路由器。如果SDN走出学术界，在工业界量产的话，那也算的上是网络硬件的革命了。难怪SDN会被称为Computer Network的X86。当然目前离大规模普及还是长路漫漫啊，具体面临的困难这里略去不表&#8230;（表不了啊）</p>

<p>以下内容参照 Coursera 的 <a href="https://class.coursera.org/sdn-001/wiki/view?page=syllabus">SDN open course</a></p>

<!--more-->


<h1>Week 1</h1>

<h2>Active Networks</h2>

<ul>
<li><p>definition: Networks where switches perform custom computations on packets.(交换机在数据包上执行自定义操作的一种网络)</p></li>
<li><p>idea: Message carry procedures &amp; data</p>

<ul>
<li><p>Active routers coexist with legacy routers</p></li>
<li><p>Each programmable switch can perform additional processing</p></li>
</ul>
</li>
<li><p>Two different approaches</p>

<ul>
<li><p>Capsules(&#8220;integrated&#8221;)(代码和数据整合到packet中)</p></li>
<li><p>Programmable Switches(&#8220;discrete&#8221;)(代码运行在路由器中，数据存储于packet，由header指定运行程序)</p></li>
</ul>
</li>
</ul>


<h2>Network Virtualization</h2>

<ul>
<li><p>definition: Representation of one or more logical network topologies on the same infrastructure.(在同一个基础设施上表现出一个或多个网络拓扑结构)</p></li>
<li><p>motivation: Separate logical network from physical infrastructure, potentially allow users to share the same underlying infrastructure for different purpose.(将逻辑的拓扑结构与物理基础设施分离以实现共享)</p></li>
<li><p>benefits:</p>

<ul>
<li><p>Sharing</p></li>
<li><p>Customizability</p></li>
</ul>
</li>
</ul>


<h1>Week 2</h1>

<h2>Control plane(控制层)</h2>

<ul>
<li><p>definition: Logic for controlling forwarding behavior(控制转发行为的逻辑，类似网络的大脑)</p></li>
<li><p>e.g. routing protocol, network middlebox configuration(firewall,Load Balance)</p></li>
</ul>


<h2>Data plane(数据层)</h2>

<ul>
<li><p>definition: Forward traffic according to control plane logic(根据控制层的逻辑来转发流量)</p></li>
<li><p>e.g. IP forwarding(即三层路由，根据IP地址进行转发), layer-2 switching(根据MAC地址进行转发)</p></li>
</ul>


<h2>Reason for separate thr Control and Data plane</h2>

<ul>
<li><p>Independent evolution and development</p></li>
<li><p>Control from high-level software program:</p></li>
</ul>


<blockquote><p>Once the control plane is separated from data plane, it&#8217;s a lot easier to control the behavior of the network, because those switches are doing nothing more than just forwarding traffic, and all the smart of network are in the software control.</p></blockquote>

<h2>Challenges from control/data plane separation</h2>

<ul>
<li><p>scalability: routing decisions for many routers</p></li>
<li><p>reliability: correct operation under failure</p></li>
<li><p>consistency: ensuring consistency across multiple control replicas</p></li>
</ul>


<h2>mininet(openflow tutorial)</h2>

<p><strong>mininet</strong> : A network emulation platform that has the ability to create a virtual OpenFlow network; controllers, switches, hosts, and links on a single real or virtual network.</p>

<h3>init</h3>

<p><code>sudo mn --topo single,3 --mac --switch ovsk --controller remote</code></p>

<ul>
<li>sudo mn : This starts mininet. Mininet always requires sudo to run.</li>
<li>&#8211;topo single,3 : This tells mininet to start using the topology of a ‘single’ switch and 3 hosts.</li>
<li>&#8211;mac : This tells mininet to assign each host a sequential mac address, matching its IP address.</li>
<li>&#8211;switch ovsk : This tells mininet that the switches are to be of the type ovsk, this is the type for Openflow,</li>
<li>&#8211;controller remote : This tells mininet that each Openflow switch is to talk to a controller, which is located at a remote location.</li>
<li>&#8211;link : This sets link parameters, e.g. bw(bandwidth), delay</li>
</ul>


<p>Here&#8217;s the topology:</p>

<p><img src="http://www.openflow.org/wk/images/c/c6/Three_switch_layout_simple.png" alt="mininet" /></p>

<h3>dpctl</h3>

<p><code>dpctl</code> is a utility that comes with the OpenFlow reference distribution and enables visibility and control over a single switch&#8217;s flow table</p>

<pre>
# forward packets coming at port 1 to port 2
dpctl add-flow tcp:127.0.0.1:6634 in_port=2,actions=output:3

# check the flow-table
dpctl dump-flows tcp:127.0.0.1:6634
</pre>


<p>Note: the <em>idle_timeout</em> para means that the flow will expire after this many secs if there is no incoming traffic.</p>

<pre>dpctl add-flow tcp:127.0.0.1:6634 in_port=2,idle_timeout=120,actions=output:3</pre>


<h3>iperf</h3>

<p><code>iperf</code> is a command-line tool for checking speeds between two computers.</p>

<pre>
# create an user space network
sudo mn --topo single,3 --controller remote --switch user
# Here we have used ‘user’ with --switch option instead of ‘ovsk’. This loads mininet with user-space switch.

# start a simple controller that acts as a learning switch without installing any flow-entries.
$ controller ptcp:

# test speed
mininet> iperf
# With the user-space switch, packets must cross from user-space to kernel-space and back on every hop, rather than staying in the kernel as they go through the switch. The user-space switch is easier to modify, but slower for simulation.

</pre>


<h2>summary</h2>

<ul>
<li><strong>OpenFlow Interface</strong> : a standard open interface between the OpenFlow controller and the OpenFlow programmable devices (i.e., switches etc)</li>
<li><strong>OpenFlow Controller</strong> : sits <em>above</em> the OpenFlow interface. The OpenFlow reference distribution includes a controller that acts as an Ethernet learning switch in combination with an OpenFlow switch. You&#8217;ll run it and look at messages being sent.</li>
<li><strong>OpenFlow Switch</strong> : sits <em>below</em> the OpenFlow interface. The OpenFlow reference distribution includes a user-space software switch. <code>Open vSwitch</code> is another software but <em>kernel-based</em> switch.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shadowsocks 源码解释]]></title>
    <link href="http://YvesChan.github.com/blog/shadowsocks-analysis/"/>
    <updated>2013-05-18T09:10:00+08:00</updated>
    <id>http://YvesChan.github.com/blog/shadowsocks-analysis</id>
    <content type="html"><![CDATA[<blockquote><p>对于科学上网这种事，我向来一丝不苟。</p>

<p>但本po的主题并不是如何科学上网，而是深入了解proxy背后的原理。</p></blockquote>

<h2>Preface</h2>

<p>去年shadowsocks在V2EX刚<a href="http://www.v2ex.com/t/32777">发布</a>的时候，我就已经开始留意这个项目。当时还在用Goagent，但有时候速度确实不咋的，而且重新配置的话会比较麻烦。9月份入手VPS之后开始折腾PPTP VPN，效果相当不稳定。不久后OpenVPN也开始受到干扰了。看来必须寻找比较小众的方式，避免躺枪。因此，初试shadowsocks（python版），速度或者稳定性都相当好，一直用到现在，未出现过什么问题。配置也很简单，唯一的门槛就是需要国外的Linux 主机（VPS）。现在shadowsocks项目已经发展到多语言跨平台了，社区也比较活跃，主要原因是项目架构简单，代码精简易于维护。</p>

<p>一周前开始学习python，主要是想用python写一个爬虫。大概用了4天的课余时间把 《Dive Into Python3》过了一遍，了解基本语法。结合文档看大牛的源码是很好的学习方式，所谓learn by doing嘛。不得不说，shadowsocks的源码真心简洁，再看一下SOCK5协议的报文格式，并没有花很多时间。貌似说了不少废话，现在入正题= =！</p>

<!--more-->


<h2>Socks5</h2>

<p>首先介绍一下socks5协议：
SOCKS协议位于传输层(TCP/UDP等)与应用层之间，其工作流程为</p>

<ol>
<li>client向proxy发出请求信息，用以协商传输方式</li>
<li>proxy作出应答</li>
<li>client接到应答后向proxy发送目的主机（destination server)的ip和port</li>
<li>proxy评估该目的主机地址，返回自身IP和port，此时C/P连接建立。</li>
<li>proxy与dst server连接</li>
<li>proxy将client发出的信息传到server，将server返回的信息转发到client。代理完成</li>
</ol>


<h3>client连接proxy的第一个报文信息，进行认证机制协商</h3>

<table border="1">
    <tr>
        <td>version</td>
        <td>nmethod</td>
        <td>methods</td>
    </tr>
    <tr>
        <td>1 Bytes</td>
        <td>1 Bytes</td>
        <td>1 to 255 Bytes</td>
    </tr>
</table>


<p>一般是 hex: 05 01 00
即：版本5，1种认证方式，NO AUTHENTICATION REQUIRED(无需认证 0x00)</p>

<h3>proxy从METHODS字段中选中一个字节(一种认证机制)，并向Client发送响应报文:</h3>

<table border="1">
    <tr>
        <td>version</td>
        <td>methods</td>
    </tr>
    <tr>
        <td>1</td>
        <td>1</td>
    </tr>
</table>


<p>一般是 hex: 05 00
即：版本5，无需认证</p>

<h3>认证机制相关的子协商完成后，Client提交转发请求:</h3>

<table border="1">
    <tr>
        <td>VER</td>
        <td>CMD</td>
        <td>RSV</td>
        <td>ATYP</td>
        <td>DST.ADDR</td>
        <td>DST.PORT</td>
    </tr>
    <tr>
        <td>1</td>
        <td>1</td>
        <td>0x00</td>
        <td>1</td>
        <td>variable</td>
        <td>2</td>
    </tr>
</table>


<p>前3个一般是 hex: 05 01 00
地址类型可以是
* 0x01    IPv4地址
* 0x03    FQDN(全称域名)
* 0x04    IPv6地址</p>

<p>对应不同的地址类型，地址信息格式也不同：
* IPv4地址，这里是big-endian序的4字节数据
* FQDN，比如&#8221;www.nsfocus.net&#8221;，这里将是:0F 77 77 77 2E 6E 73 66 6F 63 75 73 2E 6E 65 74。注意，第一字节是长度域
* IPv6地址，这里是16字节数据。</p>

<h3>proxy评估来自Client的转发请求并发送响应报文</h3>

<table border="1">
    <tr>
        <td>VER</td>
        <td>REP</td>
        <td>RSV</td>
        <td>ATYP</td>
        <td>BND.ADDR</td>
        <td>BND.PORT</td>
    </tr>
    <tr>
        <td>1</td>
        <td>1(response)</td>
        <td>0x00</td>
        <td>1</td>
        <td>variable</td>
        <td>2</td>
    </tr>
</table>


<p>Proxy可以靠DST.ADDR、DST.PORT、SOCKSCLIENT.ADDR、SOCKSCLIENT.PORT进行评估，以决定建立到转发目的地的TCP连接还是拒绝转发。若允许则响应包的REP为0，非0则表示失败（拒绝转发或未能成功建立到转发目的地的TCP连接）。</p>

<h2>shadowsocks source code</h2>

<p>源代码方面，主要是由socks5转发模块和加密解密模块组成</p>

<p>转发模块感觉比较简单，但是个人觉得有几点需要注意的地方，或者说我自己不太明白。（python菜，请谅解）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;config.json&#39;</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
</span><span class='line'>    <span class="n">config</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</span><span class='line'><span class="n">SERVER</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s">&#39;server&#39;</span><span class="p">]</span>
</span><span class='line'><span class="n">REMOTE_PORT</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s">&#39;server_port&#39;</span><span class="p">]</span>
</span><span class='line'><span class="n">PORT</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s">&#39;local_port&#39;</span><span class="p">]</span>
</span><span class='line'><span class="n">KEY</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s">&#39;password&#39;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<h3>client</h3>

<ul>
<li>从main开始，读取配置。这里为什么要用二进制的方式打开json文件呢？</li>
<li>解释命令行参数 <code>optlist, args = getopt.getopt(sys.argv[1:], 's:p:k:l:')</code>，这个跟Linux的getopt函数差不多，可以自己man一下。</li>
<li>设置logging等级和信息，生成密文表（包括加密解密）。</li>
<li>运行 ThreadingTCPServer 实例。从定义看， <code> class ThreadingTCPServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer) </code> 子类化ThreadingTCPServer（多重继承继承ThreadingMixIn类和TCPServer类），即使用多线程处理TCP请求（Mix-in class to handle each request in a new thread），同时设置其类属性allow_reuse_address。这里绑定的地址是(&#8221;,PORT)，意思是该套接字对于本机的任何地址都是可达的。BaseRequestHandler 则由 Socks5Server 子类实现。由于 SocketServer module 包含了很多socket programming的细节，所以代码看起来相当简洁。</li>
<li>每当有请求到达，调用 handle 函数，主要是建立proxy到client和server的连接，然后调用 handle_tcp 函数来转发TCP数据包(包括client to server或相反方向)，对于server来说，proxy是完全透明的。当然，这里client和proxy之间的数据交互需要通过加密传输。</li>
<li>对于handle_tcp而言，它需要同时处理两个socket（client &amp; server），这里使用了I/O multiplexing的方式，选择select作为实现。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">handle_tcp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">remote</span><span class="p">):</span>
</span><span class='line'>    <span class="k">try</span><span class="p">:</span>
</span><span class='line'>        <span class="n">fdset</span> <span class="o">=</span> <span class="p">[</span><span class="n">sock</span><span class="p">,</span> <span class="n">remote</span><span class="p">]</span>
</span><span class='line'>        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class='line'>            <span class="n">r</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">fdset</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[])</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">sock</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
</span><span class='line'>                <span class="n">data</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
</span><span class='line'>                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>                    <span class="k">break</span>
</span><span class='line'>                <span class="n">result</span> <span class="o">=</span> <span class="n">send_all</span><span class="p">(</span><span class="n">remote</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">decrypt</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</span><span class='line'>                <span class="k">if</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
</span><span class='line'>                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;failed to send all data&#39;</span><span class="p">)</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">remote</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
</span><span class='line'>                <span class="n">data</span> <span class="o">=</span> <span class="n">remote</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
</span><span class='line'>                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>                    <span class="k">break</span>
</span><span class='line'>                <span class="n">result</span> <span class="o">=</span> <span class="n">send_all</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</span><span class='line'>                <span class="k">if</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
</span><span class='line'>                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;failed to send all data&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">finally</span><span class="p">:</span>
</span><span class='line'>        <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span><span class='line'>        <span class="n">remote</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于高性能并发服务器而言，这是一种非常重要的手段。当然还是其他实现方式，例如poll,epoll,kqueue等。这里由于文件描述符数量较小，所以分别也不大了。更详细的信息可以看 <a href="http://www.kegel.com/c10k.html">C10K problem</a></p>

<h3>server</h3>

<p>服务端代码与客户端差不多，主要是数据报文的解释和转发问题。主要是处理好在client端发送过来的自定数据格式，转发到目的地址server，再将返回的数据转发给client。</p>

<p>更多的细节我都在<a href="https://github.com/YvesChan/shadowsocks">源码</a>上注释了，有兴趣可以看看。</p>

<p>整个架构图大概这样：（就不要吐槽画的有多丑了= =）</p>

<p><img src="http://ww3.sinaimg.cn/mw690/693e3eb0gw1e4uzpuiyh9j20ff0dvaat.jpg" alt="arch" /></p>

<hr />

<p>Reference:</p>

<p><a href="http://blog.csdn.net/liufan1945/article/details/8053804">Socks5详解（RFC）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Blood]]></title>
    <link href="http://YvesChan.github.com/blog/first-blood/"/>
    <updated>2013-03-19T21:54:00+08:00</updated>
    <id>http://YvesChan.github.com/blog/first-blood</id>
    <content type="html"><![CDATA[<blockquote><p>First Blood</p>

<p>出自ACM/ICPC
形容某道题第一个AC的team称为拿到了该题的 <em>First Blood</em></p></blockquote>

<p>一直想测试一下Octopress的使用体验，花了一个晚上折腾Ruby的安装环境和各种各样的奇怪问题，总算是弄好了。</p>

<p>说起来最近折腾了不少东西，比如Sublime Text 2的各种plugins，比如zsh，比如tmux，etc。真心觉得生命在于折腾啊。越来越体会到先进的工具对生产力的影响了。神器如ST2，如果使用得当，绝对是可敌IDE，但是要记得那么多快捷键也不是那么容易啊。vim的话，我也常用，但是只能算入门。大概就是八二原理吧，百分之八十的时间只用到百分之二十的功能。</p>

<p>原来的博客放在Blogspot上面，写po的时候非常不方便，比如不支持markdown，比如代码高亮要添加各种插件，比如被墙（这个才是最重要的）。另外数据导出和备份也是个问题。之前想在VPS上鼓捣wordpress，但是感觉吧，还是不够纯粹，加上WP默认主题太多槽点。Orz 虽然说WP也是有很多可折腾的地方，但是吧我发现如果不通过点什么东西来巩固我的git技能和markdown语法，估计要掉的差不多了 = =</p>

<p>网上关于octopress的教程一陀陀的，我就不重复了。然后比较蛋疼的ST2的中文输入问题一直没有解决，然后vim输入中文感觉灰常怪，所以就gedit先凑合着。突然想起一个比较蛋疼的问题：如果在别的机器上要写blog，那岂不是也要有Ruby的环境？看来要尽快考虑将静态网页生成的工作交由服务器负责了。果然什么都是有利有弊啊，更多优缺点有待发现ing&#8230;.</p>

<p>其实呢，折腾虽说是由个人喜好决定，但是也不要太过了，码农还是以敲代码为主嘛，只停留在一些应用层面上的东西没什么太大的意思，这也是我不愿意折腾UI的原因&#8230;</p>

<p>PS: 原先的Blog在<a href="http://shanks-chan.blogspot.com">Blogspot</a>由于贴代码太不方便了，而且被墙，应该不会再更新&#8230;.</p>
]]></content>
  </entry>
  
</feed>
